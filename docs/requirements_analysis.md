# 需求分析与技术规划 (Requirements Analysis & Tech Proposal)

## 📋 需求总结

| 功能模块         | 核心能力                                         | 技术挑战 |
| :--------------- | :----------------------------------------------- | :------- |
| **长期记忆**     | 人设一致性，用户信息持久化                       | ⭐⭐⭐⭐ |
| **主动性**       | 基于时间/日期/上下文主动发起对话、提醒           | ⭐⭐⭐⭐⭐ |
| **快捷状态记录** | 用户一键记录状态 (起床、洗澡)，AI 自动捕捉生活信息 | ⭐⭐⭐ |
| **多智能体**     | 群聊/私聊，每个 Agent 独立人设与记忆，共享用户信息 | ⭐⭐⭐⭐⭐ |
| **日记本**       | 自动/定时生成聊天总结日记                         | ⭐⭐⭐ |
| **Token 控制**   | Cache 命中、RAG 检索、多 Agent 协作控制成本        | ⭐⭐⭐⭐ |
| **数据持久化**   | 对话导入导出、API 日志                            | ⭐⭐ |

---

## 🧠 框架选型建议：LangGraph

**为什么选择 LangGraph 而不是 AutoGen?**

| 考量点                     | LangGraph ✅                                        | AutoGen                                      |
| :------------------------- | :-------------------------------------------------- | :------------------------------------------- |
| **状态管理 (关键！)**      | 内置强大的**集中式状态管理**，适合长期记忆和人设一致性 | 状态分散在各 Agent，需自行协调               |
| **复杂流程控制**           | 图结构，支持**循环 (Cycles)**，适合你的"主动性"需求 | 对话式驱动，更适合简单的多 Agent 聊天        |
| **多 Agent 协作**          | 支持，且可以精确控制 Agent 间的交互边界             | 核心优势，但更侧重"对话"而非"流程编排"       |
| **与 LangChain 生态兼容**  | 原生兼容 LangChain 的 RAG、LLM 连接器等             | 独立生态                                     |
| **你的需求匹配度**         | 高 (需要状态机来驱动主动行为、管理记忆)             | 中等                                         |

> [!TIP]
> **结论**：你的"主动发消息"和"复杂记忆系统"需求更适合 **LangGraph** 的状态机模型。AutoGen 更适合"一群 AI 在群里自己聊天"的场景。

---

## 🏛️ 初步架构设想

```mermaid
graph TD
    subgraph 用户端 (PWA)
        A[手机 / 电脑浏览器] -- "发消息 / 快捷状态" --> B(API Gateway)
    end

    subgraph 后端 (Python)
        B --> C{LangGraph Orchestrator}
        C -- "调用" --> D[Agent 1: 主陪伴]
        C -- "调用" --> E[Agent 2: 其他人设]
        C -- "触发" --> F[Scheduler: 主动消息]
        D & E --> G[(Vector DB: 记忆)]
        D & E --> H[(SQL DB: 用户状态/日志)]
        F --> C
    end

    subgraph LLM API
        D & E --> I(OpenAI / Gemini / ...)
    end
```

**技术栈初步建议**：

| 层级     | 技术                     | 理由                                         |
| :------- | :----------------------- | :------------------------------------------- |
| 前端     | **PWA (渐进式网页应用)** | 可安装到 iPhone 主屏幕，类似 App，开发成本低 |
| 后端     | **FastAPI (Python)**     | 异步，性能好，LangGraph 原生 Python          |
| Agent    | **LangGraph**            | 如上分析                                     |
| 记忆检索 | **Chroma / Milvus**      | 向量数据库，用于 RAG 和记忆检索              |
| 结构数据 | **PostgreSQL**           | 用户状态、日志、对话记录等                   |
| 调度     | **APScheduler / Celery** | 定时任务，驱动 AI 主动发消息                 |

---

## ❓ 需要你细化/确认的问题

在进入详细设计前，我需要你帮我澄清一些点，这将直接影响技术选型的最终决定：

1.  **"主动消息"的触发机制**：
    *   你期望的"主动问候"是完全由 AI 根据规则/记忆自己决定发什么，还是你也想定义一些"模板"（比如固定在早上 8 点问候）？
    answer:不要太固定的类似早上八点的这种。我希望是动态随机的。但我也没太想好怎么实现，就是像人一样有时候发有时候不发，太久没有用户的信息就主动发问一下。或者用户早上九点了还没起就问一下。也会根据用户的数据和上下文问一下，比如说看见用户有学习计划就督促一下，用户做完了就鼓励一下。用户心情不好多关心一下什么的。比较有陪伴感真人感的。但我也不知道咋实现，你有什么建议么？
    *   这些主动消息，你希望通过什么方式接收？（手机推送通知？打开 App 后才能看到？）
    手机推送通知，点进去直接跳转到AI发的主动消息那里，然后我可以接着聊，AI也知道我是接着它发的信息聊的。像微信一样

2.  **多智能体群聊的交互细节**：
    *   当一个 Agent 在群聊里发消息后，其他 Agent 的响应是"自动触发"还是需要你 `@` 它才会说话？
    我想的是结合起来。就是根据这个Agent的人设，有一个概率去触发调用。也会在某些AI关注的关键词的时候触发调用。这个是后台自动的、有概率的、遵循规则的。然后用户@某个Agent后，就一定触发调用，让这个Agent发言。
    *   你希望自己创建和管理 Agent 的人设吗？（比如通过一个设置界面？）
    希望的。但最好能像命令行一样通过命令设置吧，懒得调整前端...我编辑好人设直接在手机粘进去。然后自动写库和融入后端的逻辑

3.  **"AI 自主捕捉生活信息"的边界**：
    *   你希望 AI 自动从对话中提取什么样的信息？（比如：我明天有考试 -> 自动记录"明天有考试"？）
    提取的信息参考我下面写的。主要是我的一些日常活动。AI需要额外记录的是我情绪、心情、思考方面的内容。因为这些我往往自己记不住要记

    *   这个"自动捕捉"需要多精确？是允许 AI 自由发挥，还是你更倾向于手动确认后再入库？
    全都自由发挥，不用手动确认。我会定期在数据库管理，删掉不需要的。
    但是我需要可以主动记录，就是我直接点一下快捷的，或者输命令，自己落库。我们可以设计一下常用的快捷的。比如说早中晚饭、奶茶/咖啡、外出活动、考试、学习计划、完成学习计划、洗澡、起床、睡觉等等。可以加详细备注也可以不加。

4.  **MVP 的范围**：
    *   以上功能都很棒，但哪些是 **V1.0 必须有**的？我们可以先聚焦核心，再逐步迭代。
    *   建议 MVP：基础对话 + 长期记忆 + 一个 Agent 的主动消息 + 快捷状态记录。多智能体群聊可以放到 V1.1。

    我采纳你的建议。我们可以列出一个轻松+可行的开发计划。每天做出一部分就行。我不是很着急，这是我自己想为自己开发的项目。算是我尝试规范开发流程+AI协作+娱乐心情的一个项目。我们聚焦在每一个功能实现时的规范流程、文档产出、功能实现的逻辑和我学习到的没接触过的新技术就行，并不需要急着做出一个要交付的产品。在开发时我希望我们的系统设计和编码都比较有逻辑、优雅，不要互相耦合

---

请在这个文档里直接回复你的想法，或者告诉我，我们可以继续深入讨论！
